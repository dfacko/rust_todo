#[macro_use]
extern crate diesel;
extern crate dotenv;

mod models;
mod routes;
mod schema;
use self::diesel::prelude::*;
use self::models::*;
use actix_web::{web, App, HttpServer};
use diesel::r2d2::{self, ConnectionManager};

pub type Pool = r2d2::Pool<ConnectionManager<PgConnection>>;

#[actix_rt::main]
async fn main() -> std::io::Result<()> {
    //let connection = establish_connection();

    dotenv::dotenv().ok();
    let database_url = std::env::var("DATABASE_URL").expect("Database not foudn");
    let connection = PgConnection::establish(&database_url).expect("Cannot connect to db");
    let connection_pool = Pool::builder();

    create_list(&connection, "Lista2").await.unwrap();
    //println!("{}", delete_list(&connection, 1).await);
    read_lists(&connection).await;
    HttpServer::new(move || App::new().route("/", web::get().to(routes::home)))
        .bind("127.0.01:8080")?
        .run()
        .await
}

pub fn establish_connection() -> PgConnection {
    dotenv::dotenv().ok();
    let database_url = std::env::var("DATABASE_URL").expect("Database not foudn");
    PgConnection::establish(&database_url).expect("Cannot connect to db")
}

pub async fn create_list(
    conn: &PgConnection,
    title: &str,
) -> Result<TodoList, diesel::result::Error> {
    /*use schema::todo_list;
    let new_list = TodoListNew { title: title };

    diesel::insert_into(todo_list::table)
        .values(&new_list)
        .get_result(conn)*/
    TodoList::create_list(conn, title).await
}

pub async fn read_lists(conn: &PgConnection) {
    println!("{:?}", TodoList::get_all_lists(conn).await.unwrap());
}

pub async fn delete_list(conn: &PgConnection, id: i32) -> String {
    TodoList::delete_list(conn, id).await
}
